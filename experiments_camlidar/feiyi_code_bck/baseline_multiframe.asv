clc, clear;
close all;

data_option = 2;
data_type = 'real_data';
data_fold = {'real_data_1', 'real_data_2', 'real_data_3'};

% data_option = 1;
% data_type = 'simu_data';
% data_fold = {'noise-free', 'noise-0.015', 'noise-0.03'};

%%
imagePath = fullfile(data_type, data_fold{data_option}, 'img');
ptCloudPath = fullfile(data_type, data_fold{data_option}, 'pcd');
imds = imageDatastore(imagePath); 
pcds = fileDatastore(ptCloudPath, 'ReadFcn', @pcread); 
imageFileNames = imds.Files;
ptCloudFileNames = pcds.Files;

intrinsic = load(fullfile(data_type, data_fold{data_option}, 'calibration.mat'));
params = load(fullfile(data_type, data_fold{data_option}, 'params.mat'));
squareSize = params.squareSize; 
checkerboardPadding = params.checkerboardPadding;
TGt = params.TGt;

rng('default');

%% Extract features
% Extract Checkerboard corners from the images
[imageCorners3d, checkerboardDimension, dataUsed] = ...
    estimateCheckerboardCorners3d(imageFileNames, intrinsic.cameraParams, squareSize);
% helperShowImageCorners(imageCorners3d, imageFileNames, intrinsic.cameraParams)

imageFileNames = imageFileNames(dataUsed); % Remove image files that are not used
% Filter point cloud files corresponding to the detected images
ptCloudFileNames = ptCloudFileNames(dataUsed);
% Extract ROI from the detected image corners
roi = helperComputeROI(imageCorners3d, 5);

%Extract Checkerboard in lidar data
checkerboard3DDimension = checkerboardDimension + checkerboardPadding;
if (data_option >= 2 && strcmp(data_type, 'real_data'))
  [lidarCheckerboardPlanes, framesUsed, indices] = detectRectangularPlanePoints(...
      ptCloudFileNames, checkerboard3DDimension, ...
      'RemoveGround', false, 'ROI', roi, 'DimensionTolerance', 0.2);
  % helperShowCheckerboardPlanes(ptCloudFileNames, indices)
else
  [lidarCheckerboardPlanes, framesUsed, indices] = detectRectangularPlanePoints(...
    ptCloudFileNames, checkerboard3DDimension, ...
    'RemoveGround', true, 'ROI', roi, 'DimensionTolerance', 0.2);
  % helperShowCheckerboardPlanes(ptCloudFileNames, indices)  
end

%% Calibration
avail_ptCloudFileNames = ptCloudFileNames(framesUsed);
avail_imageCorners3d = imageCorners3d(:, :, framesUsed);
avail_imageFileNames = imageFileNames(framesUsed);
avail_lidarCheckerPlanes = lidarCheckerboardPlanes(framesUsed);

aver_t_err = [];
aver_r_err = [];
poseNum = 0;
for idx = 1:length(framesUsed)
  if (framesUsed(idx) == 0) 
    continue;
  end
  fUsed = framesUsed(1:idx);
  tmp_ptCloudFileNames = ptCloudFileNames(fUsed);
  tmp_imageCorners3d = imageCorners3d(:, :, fUsed);
  tmp_imageFileNames = imageFileNames(fUsed);
  tmp_lidarCheckerPlanes = lidarCheckerboardPlanes(fUsed);

  t_errs= [];
  multi_theta_errs=[];
  for iter = 1:100
    [tform, errors] = estimateLidarCameraTransform(tmp_lidarCheckerPlanes, ...
        tmp_imageCorners3d, 'CameraIntrinsic', intrinsic.cameraParams);
  %   helperFuseLidarCamera(tmp_imageFileNames, tmp_ptCloudFileNames, indices, intrinsic.cameraParams, tform);
    
    % save MATLAB calibration results
    % matlab's tform format is the transpose of traditional format
    % MATLAB: p_trans = p * tform.Rotation + tform.Translation is a 1x3 vector. 
    % Ours: p_trans = tform.Rotation * p + tform.Translation is a 3x1 vector
    TOptm = eye(4, 4);
    TOptm(1:3, 1:3) = tform.Rotation';
    TOptm(1:3, 4) = tform.Translation';
    deltaT = inv(TGt) * TOptm;
    deltaQ = rotm2quat(deltaT(1:3,1:3));
    angle_err = abs(2*acosd(deltaQ(1)));
%     r_err = [r_err, angle_err];  %% deg
%     t_err = [t_err, norm(deltaT(1:3,4))];  %% m
    multi_theta_errs = [multi_theta_errs, angle_err];
    t_errs = [t_errs, norm(deltaT(1:3,4))];
  end
  aver_t_err = [aver_t_err,t_errs'];
  aver_r_err = [aver_r_err,multi_theta_errs'];
  sprintf('idx: %d', idx)
end
save(fullfile(data_type, data_fold{data_option}, 'result_baseline.mat'), 'aver_r_err', 'aver_t_err', 'TOptm');



























